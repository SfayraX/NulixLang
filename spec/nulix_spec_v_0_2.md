# **Nulix Language Specification v0.2 (Draft)**

### **Статус документа:** Черновик архитектуры
### **Цель:** Определение базовой философии, структуры, уровней абстракции и ключевых механизмов языка Nulix. Версия **0.2** — сбор ядра идей перед формированием строгой спецификации v1.0.

---

# **0. Преамбула**
Nulix — универсальный язык системного уровня, созданный для того, чтобы **один и тот же код мог эволюционировать**:
- из прототипа → в продакшен,
- из высокоуровневого кода → в low‑level оптимизацию,
- из скриптового подхода → в строгую систему типов,
- из backend‑логики → в HFT/embedded ядро.

Главная уникальность Nulix:
> **Многоуровневая модель абстракции и строгости, позволяющая одному языку покрывать ВСЮ пирамиду разработки — от Python до ASM.**

Nulix сочетает:
- удобство Python,
- безопасность Rust,
- скорость C/ASM,
- гибкость Julia,
- практичность Go.

---

# **1. Философия языка Nulix**
Основные принципы:

## **1.1. Один язык для всего**
Backend, системное программирование, AI, Data Science, realtime, HFT, embedded — всё на одном синтаксисе.

## **1.2. Zero-Cost Abstractions**
Любая высокоуровневая конструкция должна компилироваться без накладных расходов.

## **1.3. Safety Without GC**
Безопасность памяти достигается через автоматический анализ владения и заимствований, без сборщика мусора.

## **1.4. Predictable Performance**
Предсказуемость важнее скорости. Nulix избегает скрытых аллокаций или магии.

## **1.5. Многоуровневые абстракции**
От `@high` (Python) → до `@naked` (ASM), в одном языке.

## **1.6. Постепенное ужесточение (Gradual Hardening)**
Код может «взрослеть» без переписывания:
- `@prototype`
- `@develop`
- `@production`
- `@strict`

## **1.7. Читаемость превыше всего**
Синтаксис должен быть простым, визуально чистым и понятным даже новичкам.

---

# **2. Синтаксис языка**
- Отступы значимы
- Двоеточие открывает блок
- Типы указываются как `name: Type`
- Возврат — последнее выражение
- Нет `;`

Пример:
```
proc add(a: i32, b: i32) -> i32:
    a + b
```

---

# **3. Примитивные типы**
## **3.1. Числа**
```
i8..i64
u8..u64
f32, f64
```

## **3.2. Логические типы**
```
bool
```

## **3.3. Строки и символы**
```
char
str
String
```

## **3.4. Коллекции**
```
[T]
{key: value}
```

---

# **4. Переменные**
```
let x: i32 = 5
mut s: String = "hello"
```
Shadowing разрешён.

---

# **5. Управляющие конструкции**
```
if cond:
    ...
elif cond:
    ...
else:
    ...

for i in 0..10:
    ...

while cond:
    ...

match value:
    case 1: ...
    case _: ...
```

---

# **6. Функции и процедуры**
```
proc name(args) -> Type:
    ...
```
- параметры по значению
- ссылки `&T`, `&mut T`
- `auto` — вывод типов

Последняя строка — возвращаемое значение.

---

# **7. Структуры, Enum, Traits, Generics**

## **7.1. Структуры**
```
struct Point:
    x: f64
    y: f64
```

## **7.2. Enum**
```
enum Result[T, E]:
    Ok(value: T)
    Err(error: E)
```

## **7.3. Traits**
```
trait Display:
    proc fmt(self) -> String
```

## **7.4. Generics (мономорфизация)**
```
proc max[T: Ord](a: T, b: T) -> T:
    if a > b: a else: b
```

---

# **8. Уровни Абстракции Nulix**
Основополагающая система языка.

## **8.1. @high — высокоуровневый (Python-стиль)**
- автоматическая память
- динамика
- удобство

```
@high proc main:
    let df = load_csv("data.csv")
    print(df.rows)
```

## **8.2. @system — средний уровень (Rust-стиль)**
- строгие типы
- владение и заимствования
- оптимизация

## **8.3. @low — низкоуровневый (C-стиль)**
- указатели
- FFI
- ручная память

## **8.4. @naked — уровень "голого металла" (ASM)**
```
@naked proc atomic_update:
    asm:
        lock inc [counter]
```

---

# **8.5. Автоматические мосты между уровнями**

## **Понижение уровня (high → low)**
```
@high proc bot:
    let sig = @system analyze(data)
    @low execute(sig)
```

## **Повышение уровня (low → high)**
```
@low proc handler(ptr: *u8, len: i32) -> DataFrame:
    let safe = @system validate(ptr, len)
    let df = @high parse(safe)
    return df
```

Компилятор сам генерирует:
- безопасные обёртки
- конвертации типов
- границы
- проверки владения

---

# **9. Уровни строгости (Gradual Hardening)**

## **9.1. @prototype — максимальная свобода**
- не обязательны типы
- минимум ограничений
- быстрые эксперименты

## **9.2. @develop — уточнение**
- типы желательны
- мягкие предупреждения

## **9.3. @production — строгая безопасность**
- типы обязательны
- Result вместо исключений
- контроль владения

## **9.4. @strict — ядро системы**
- полная детерминированность
- запрет динамики
- запрет автоконверсий

---

# **10. Владение, заимствования, времени жизни**
Базовые правила:

1. Один владелец.
2. Несколько `&T`, только один `&mut T`.
3. Lifetimes выводятся автоматически.

Пример:
```
@system proc borrow(v: &Vec[i32]):
    println(v.len())
```

---

# **11. Ошибки и механизм Result**

## **11.1. Только Result**
```
proc parse(s: String) -> Result[i32, ParseError]:
```

## **11.2. Оператор ?**
```
let x = try_parse()?
```

## **11.3. panic()**
Разрешён только в:
- @low
- unsafe
- debug-режиме

---

# **12. Асинхронность и акторы**
## **12.1. Определение актора**
```
@light actor Network:
    async proc handle():
        let d = await sock.read()
        process(d)
```

## **12.2. Типы акторов**
- @light — IO
- @burst — CPU ≤ 200 μs
- @heavy — долгие вычисления
- @pinned — realtime
- @auto — компилятор выбирает сам

---

# **13. Runtime и модель исполнения**
Планировщики:
- LightScheduler
- BurstScheduler
- HeavyScheduler
- PinnedScheduler

Переклассификация задач при превышении бюджетов.

---

# **14. Модель памяти**
- heap
- stack
- pinned-heap
- arena
- thread-local allocators

---

# **15. Unsafe**
Разрешает:
- raw pointers
- manual memory
- FFI
- отключение проверок
- inline asm

---

# **16. FFI**
```
extern "C" proc c_sin(x: f64) -> f64
```

---

# **17. Инструменты и сборка**
```
nulix new
nulix build
nulix run
nulix test
nulix fmt
```

AOT — по умолчанию
JIT — через OrcJIT

---

# **18. Форматтер и стиль**
- snake_case
- PascalCase для типов
- обязательный auto‑fmt

---

# **19. Дебаггер**
- DWARF
- async-aware backtraces
- отображение акторов
- логи сообщений

---

# **20. Приложения**

## **20.1. Минимальная программа**
```
proc main():
    println("Hello, Nulix!")
```

## **20.2. Пример микросервиса**
*(заготовка для v0.3)*

---

# **Конец спецификации Nulix v0.2 (Draft)**

Документ является архитектурным ориентиром. В дальнейших версиях будут расширены разделы, добавлены примеры, формальные правила и диаграммы.

